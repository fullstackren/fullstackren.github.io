(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{479:function(i,n,v){"use strict";v.r(n);var _=v(14),e=Object(_.a)({},(function(){var i=this,n=i._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":i.$parent.slotKey}},[n("h1",{attrs:{id:"mixins的所有缺陷"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mixins的所有缺陷"}},[i._v("#")]),i._v(" mixins的所有缺陷")]),i._v(" "),n("p",[i._v("mixins可以把组件逻辑提取到可复用的单元里。然而 mixins 有三个主要的短板：")]),i._v(" "),n("p",[i._v("1、"),n("code",[i._v("不清晰的数据来源")]),i._v("：当使用了多个 mixin 时，实例上的数据属性来自哪个 mixin 变得不清晰，这使"),n("code",[i._v("追溯实现")]),i._v("和"),n("code",[i._v("理解组件行为")]),i._v("变得困难。这也是Vue3推荐在组合式函数中使用 "),n("code",[i._v("ref + 解构模式")]),i._v("的理由：让属性的来源在消费组件时一目了然。\n2、"),n("code",[i._v("命名空间冲突")]),i._v("：多个来自不同作者的 mixin 可能会"),n("code",[i._v("注册相同的属性名")]),i._v("，造成命名冲突。若使用组合式函数，你可以通过在"),n("code",[i._v("解构变量")]),i._v("时对变量进行重命名来"),n("code",[i._v("避免相同的键名")]),i._v("。\n3、"),n("code",[i._v("隐式的跨 mixin 交流")]),i._v("：多个 mixin 需要依赖共享的属性名来进行相互作用，这使得它们隐性地耦合在一起。而一个组合式函数的返回值可以作为另一个组合式函数的参数被传入，像普通函数那样。")]),i._v(" "),n("p",[i._v("基于上述理由，不推荐在 Vue3 中继续使用 mixin。保留该功能只是为了项目迁移的需求和照顾熟悉它的用户。")])])}),[],!1,null,null,null);n.default=e.exports}}]);